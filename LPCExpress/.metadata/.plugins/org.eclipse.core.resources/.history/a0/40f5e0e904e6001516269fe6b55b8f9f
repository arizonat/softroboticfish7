/*
 * Modem.h
 *
 *  Created on: Mar 8, 2016
 *      Author: Joseph
 */

#ifndef ACOUSTIC_ACOUSTICCONTROLLER_H_
#define ACOUSTIC_ACOUSTICCONTROLLER_H_

#include "ToneDetector.h"

#define defaultBaudUSB 115200 // 921600 for fish deployment (to be fast enough to keep up with data stream)

#define infiniteLoop     // if undefined, will stop after loopCount buffers are processed
#define loopCount 20000  // number of buffers to process before terminating the program

//#define threshold1 // older algorithm for processing Goertzel buffers (not sure if it still works)
#define threshold2

//#define artificialPowers // will use tone powers saved in a file rather than actually sampling (expects two tab-separated columns of powers in /local/powers.wp)
//#define singleDataStream // just read a single continuous stream of bits (as opposed to segmenting into words/decoding)

//#define controlFish // whether to start fishController to control the servos and motor
#define useAGC        // if undefined, will only set agc (adjustable gain control of the acoustic input board) once at startup
//#define AGCLeds     // if defined, will light the mBed LEDs to indicate the chosen agc gain index (whether or not useAGC is on)

//#define saveData   // save data such as received words to an array, then save it to a file at the end - faster than printing continuously but worry about overflow
//#define streamData // stream data to the screen as it's received (controlled independently of saveData)
//#define streamSignalLevel // stream current signal level to the screen

#define dataRate 20 // data rate in bps.  Can be 20, 50, 77, or 100.  20 was used in Fiji. Above 50 may be less reliable.

#define lowBatteryVoltagePin p26

class AcousticController
{
	public:
		// Initialization
		AcousticController();
		void init(usbSerialObject* = NULL);
		// Execution control
		void run();
		void stop();
	private:
		// Control
		volatile uint3_t bufferCount;
		Timer programTimer;
		Serial* usbSerial;

		// Called by toneDetector when new tone powers are computed
		void processTonePowers(int32_t* newTonePowers, uint32_t signalLevel);
		#ifndef singleDataStream
		// Use Hamming code to decode the data word and check for an error
		void decodeDataWord(volatile bool* data);
		#endif

		// TODO check what actually needs to be volatile

		// Data detection
		volatile bool waitingForEnd;     // got data, now waiting until next bit transmission is expected (waiting until "period" buffers have elapsed since edge)
		volatile uint16_t periodIndex;   // how many buffers it's been since the last clock edge
		volatile uint8_t fskIndex;       // which set of 0/1 frequencies are next expected

		#if defined(threshold2)
		#define powerHistoryLength 50       // number of buffer results to consider when deciding if a tone is present.  should be half of a bit-width
		#define powerHistoryDetectWindow 20 // portion of powerHistory to consider as the detection zone (where a peak is expected)
		volatile int32_t powerHistory[powerHistoryLength][numTones];  // History of Goertzel results for the last powerHistoryLength buffers
		volatile int16_t powerHistoryIndex;                   // Index into powerHistory (circular buffer)
		volatile int16_t powerHistoryDetectIndex;             // Marks where in powerHistory to start window for detection; will always be detectWindow elements behind powerHistoryIndex in the circular buffer
		volatile int32_t powerHistorySumDetect[numTones];     // Sum of powers stored in powerHistory in the detect window (stand-in for mean)
		volatile int32_t powerHistorySumNoDetect[numTones];   // Sum of powers stored in powerHistory outside the detect window (stand-in for mean)
		volatile int32_t powerHistoryMaxDetect[numTones];     // Max of powers stored in powerHistory in the detect window
		volatile int32_t powerHistoryMaxNoDetect[numTones];   // Max of powers stored in powerHistory outside the detect window
		volatile bool readyToThreshold;                       // Whether powerHistory has been filled at least once
		volatile bool tonesPresent[detectWindow][numTones];   // Circular buffer of whether tones were detected in last detectWindow powers
		volatile uint8_t detectSums[numTones];                // Rolling sum over last detectWindow tonesPresent results (when > detectWindow/2, declares data bit)
		volatile uint8_t detectWindowIndex;
		#elif defined(threshold1)
		#define powerHistoryLength 50                       // number of results to consider when deciding if a tone is present.  should be half of a bit-width
		volatile uint8_t detectSums[numTones];              // Rolling sum over last detectWindow buffer results (when > detectWindow/2, declares clock/data)
		int32_t powerHistory[powerHistoryLength][numTones]; // History of Goertzel results for the last powerHistoryLength buffers
		volatile int16_t powerHistoryIndex;                 // Index into powerHistory (circular buffer)
		volatile int16_t powerHistoryDetectIndex;           // Marks where in powerHistory to start window for detection; will always be detectWindow elements behind powerHistoryIndex in the circular buffer
		int32_t powerHistorySum[numTones];                  // Sum of powers stored in powerHistory (stand-in for mean)
		int32_t powerHistoryMax[numTones];                  // Max of powers stored in powerHistory
		volatile bool readyToThreshold;                     // Whether powerHistory has been filled at least once
		#endif

		// Segmenting of data into bits/words
		#if defined(singleDataStream) && defined(saveData)
			volatile bool data[loopCount/(bitPeriod) * (numTones-1) + 50]; // Received data (each clock pulse is associated with numTones-1 bits) // TODO update for multi-hop FSK, but this is fine for one FSK group
			volatile uint16_t dataIndex;
		#else
			#define dataWordLength 16          // bits per word.  note that changing this also requires adjusting the decodeDataWord algorithm, since it currently assumes Hamming encoding
			volatile uint8_t dataBitIndex;     // current bit of that word
			volatile bool interWord;           // whether we are currently in between words (waiting out the long inter-word pause)
			void decodeDataWord(volatile bool* data);
			#ifdef saveData
			volatile bool data[loopCount/(bitPeriod*dataWordLength)][dataWordLength]; // Each element is a word as an array of bits
			volatile uint16_t dataWordIndex;   // current data word
			#else
			volatile bool dataWord[dataWordLength]; // an array of bits making up the current word
			#endif
		#endif
		volatile uint16_t lastDataWord; // not used anymore, but still updated

		// Adjustable gain control (AGC)
		const uint8_t agcGains[] = {1, 1, 2, 5, 10, 20, 50, 100};  // the possible gains of the AGC
		const uint8_t agcGainsLength = sizeof(agcGains)/sizeof(agcGains[0]);
		volatile uint8_t currentGainIndex; 		  // the current index into agcGains
		const uint16_t signalLevelBufferLength = (10000000)/(sampleWindow*sampleInterval);         // first constant is window length for updating agc in microseconds
		const int32_t signalLevelSumDesired = ((uint32_t)500)*((uint32_t)signalLevelBufferLength); // desire about 2 VPP, so signal minus offset should have 1V amplitude, so say mean a bit smaller, about 0.4V ~= 500
		volatile int32_t signalLevelSum; 		  // the running sum of signal level readings
		volatile uint16_t signalLevelBufferIndex; // index into signal level buffer // note we don't have a buffer anymore, but use this to know when to reset the sum

		DigitalOut gain0(p16);
		DigitalOut gain1(p17);
		DigitalOut gain2(p18);
		DigitalOut agc[3] = {gain0, gain1, gain2}; // facilitates loops and whatnot
		#ifdef AGCLeds
			#undef debugLEDs
			DigitalOut agcLED0(LED1);
			DigitalOut agcLED1(LED2);
			DigitalOut agcLED2(LED3);
			DigitalOut agcLEDs[3] = {agcLED0, agcLED1, agcLED2};
		#endif

		// Fish reset timeout
		const uint16_t fishResetTimeout = 5000000/(sampleWindow*sampleInterval); // first constant is timeout in microseconds
		volatile uint16_t timeSinceGoodWord; // measured in buffers

		// Low battery monitor
		DigitalIn lowBatteryVoltage;
		void lowBatteryCallback();

		// Testing/debugging
		#ifdef artificialPowers
		    #if !defined recordStreaming || (!defined recordOutput && !defined recordSamples)
		    LocalFileSystem local("local");
		    #endif
		    FILE* finPowers = fopen("/local/powers.wp", "r");
		    int32_t nextPowers[numTones];
		#endif
};


// Sampling / Thresholding configuration
// 20 bps (5/45 ms tone/silence)
#if dataRate == 20
#define detectWindow 10    // number of buffers to look at when deciding if a tone is present
#define detectThresh 6     // number of 1s that must be present in a detectWindow group of buffer outputs to declare a tone present
#define period 80          // the number of buffers from a rising edge to when we start looking for the next rising edge
#define bitPeriod 100      // only used with saveData: how many buffers it should actually be between rising edges (only used to size the data array)
#define interWordWait 300  // how many buffers of silence to expect between words
#elif dataRate == 50
// 50 bps (5/15 ms tone/silence)
#define detectWindow 10    // number of buffers to look at when deciding if a tone is present
#define detectThresh 6     // number of 1s that must be present in a detectWindow group of buffer outputs to declare a tone present
#define period 20          // the number of buffers from a rising edge to when we start looking for the next rising edge
#define bitPeriod 40       // only used with saveData: how many buffers it should actually be between rising edges (only used to size the data array)
#define interWordWait 300  // how many buffers of silence to expect between words
#elif dataRate == 77
// 77 bps (5/8 ms tone/silence)
#define detectWindow 10    // number of buffers to look at when deciding if a tone is present
#define detectThresh 6     // number of 1s that must be present in a detectWindow group of buffer outputs to declare a tone present
#define period 10          // the number of buffers from a rising edge to when we start looking for the next rising edge
#define bitPeriod 26       // only used with saveData: how many buffers it should actually be between rising edges (only used to size the data array)
#define interWordWait 300  // how many buffers of silence to expect between words
#elif dataRate == 100
// 100 bps (5/5 ms tone/silence)
#define detectWindow 10    // number of buffers to look at when deciding if a tone is present
#define detectThresh 6     // number of 1s that must be present in a detectWindow group of buffer outputs to declare a tone present
#define period 6           // the number of buffers from a rising edge to when we start looking for the next rising edge
#define bitPeriod 20       // only used with saveData: how many buffers it should actually be between rising edges (only used to size the data array)
#define interWordWait 300  // how many buffers of silence to expect between words
#endif









// Main loop
int main()
{
    lowBatteryVoltage.mode(PullUp);
    lowBatteryInterrupt.fall(&lowBatteryCallback);

    wait(0.5);
    pc.baud(115200);

    //printf("\n===== Hello 16 =====\n");
    //printf("(ToneDetector test)\n");
    //printf("\n");
    wait(1);

    // Create file for logging data words
	#ifdef saveData
    LocalFileSystem local("local");
    FILE* foutDataWords;
    int fileNum = -1;
    char filename[25];
    foutDataWords = NULL;
    do
    {
    	fileNum++;
    	fclose(foutDataWords);
    	sprintf(filename, "/local/%d.txt", fileNum);
    	foutDataWords = fopen(filename, "r");
    	printf("%d\n", fileNum);
    } while(foutDataWords != NULL);
    foutDataWords = fopen(filename, "w");
    /*Timer t1;
    t1.start();
    uint32_t test[5] = {123000, 122000, 121000, 1, 119};
    for(uint32_t i = 0; i < 1000; i++)
    	printf("%ld %ld %ld %d %d\n", test[0], test[1], test[2], test[3], test[4]);
    	//fwrite(test, 4, 3, foutDataWords);
    t1.stop();
    fclose(foutDataWords);
    printf("time:%d\n", t1.read_us());
    while(true);*/
	#endif

    // Configure the tone detector
    toneDetector.setCallback(&processTonePowers);
    toneDetector.init();

    // Clear detection arrays
    #if defined(threshold2)
    for(int t = 0; t < numTones; t++)
    {
        detectSums[t] = 0;
        for(uint8_t p = 0; p < detectWindow; p++)
            tonesPresent[p][t] = 0;
    }
    detectWindowIndex = 0;
    readyToThreshold = false;
    powerHistoryIndex = 0;
    powerHistoryDetectIndex = (powerHistoryLength - 1) - (powerHistoryDetectWindow-1) + 1; // assumes powerHistoryLength >= detectWindow > 1
    for(uint8_t t = 0; t < numTones; t++)
    {
        powerHistorySumDetect[t] = 0;
        powerHistorySumNoDetect[t] = 0;
        powerHistoryMaxDetect[t] = 0;
        powerHistoryMaxNoDetect[t] = 0;
        for(uint16_t p = 0; p < powerHistoryLength; p++)
        {
            powerHistory[p][t] = 0;
        }
    }
    #elif defined(threshold1)
    for(int t = 0; t < numTones; t++)
    {
        detectSums[t] = 0;
    }
    powerHistoryIndex = 0;
    powerHistoryDetectIndex = (powerHistoryLength - 1) - (detectWindow-1) + 1; // assumes powerHistoryLength >= detectWindow > 1
    for(uint8_t t = 0; t < numTones; t++)
    {
        powerHistorySum[t] = 0;
        powerHistoryMax[t] = 0;
        for(uint16_t p = 0; p < powerHistoryLength; p++)
        {
            powerHistory[p][t] = 0;
        }
    }
    readyToThreshold = false;
    #endif
    #ifdef singleDataStream
        #ifdef saveData
        dataIndex = 0;
        #endif
    #else
        #ifdef saveData
        dataWordIndex = 0;
        #endif
        dataBitIndex = 0;
        interWord = false;
    #endif
    waitingForEnd = false;
    periodIndex = 0;
    fskIndex = 0;

    // Initialize adjustable gain control
    signalLevelBufferIndex = 0;
    signalLevelSum = 0;
    currentGainIndex = 4;
    for(uint8_t i = 0; i < sizeof(agc)/sizeof(agc[0]); i++)
    {
        agc[i].write(currentGainIndex & (1 << i));
        #ifdef AGCLeds
        agcLEDs[i].write(currentGainIndex & (1 << i));
        #endif
    }

    #ifdef controlFish
    // Start the fish controller
    fishController.start();
    #endif

    #ifndef artificialPowers
    // Start listening for tones
    timer.start();
    toneDetector.run();
    timer.stop();
    toneDetector.finish(); // we won't include the time this takes to write files in the elapsed time
    #else
    // Read powers from file
    printf("newPower[0] \tnewPower[1] \tdetectSums[0] \tdetectSums[1] \tsum[0] \tsum[1] \tmax[0] \tmax[1] \tfskIndex \twaiting \tperiodIndex \n");
    int32_t maxSignalValTemp = 0;
    int res = fscanf(finPowers, "%ld\t%ld\n", &nextPowers[0], &nextPowers[1]);
    while(res > 0)
    {
        processTonePowers(nextPowers, maxSignalValTemp);
        res = fscanf(finPowers, "%ld\t%ld\n", &nextPowers[0], &nextPowers[1]);
    }
    fclose(finPowers);
    #endif

    #ifdef controlFish
    // Stop the fish controller
    fishController.stop();
    #endif

    // Print results
    int elapsed = timer.read_us();
    printf("\n");
    printf("Buffers processed: %ld\n", count);
    printf("Elapsed time  : %d us\n", elapsed);
    printf("Per-sample time : %f us\n", (double)elapsed/(double)count/(double)sampleWindow);
    printf("  Sample frequency: %f kHz\n", (double)count*(double)sampleWindow/(double)elapsed*1000.0);
    printf("Per-buffer time : %f us\n", (double)elapsed/(double)count);
    printf("  Buffer-processing frequency: %f kHz\n", (double)count/(double)elapsed*1000.0);

    printf("\nComputed powers from last buffer: \n");
    int32_t* lastTonePowers = toneDetector.getTonePowers();
    for(int i = 0; i < numTones; i++)
        printf("  Tone %d: %f Hz -> %f\n", i, targetTones[i], toFloat(lastTonePowers[i]));

    #if defined(singleDataStream) && defined(saveData)
    printf("\nData received (%d bits):\n", dataIndex);
    fprintf(foutDataWords, "\nData received (%d bits):\n", dataIndex);
    long errors = 0;
    for(int d = 5; d < dataIndex; d++)
    {
        printf("%d", data[d]);
        fprintf(foutDataWords, "%d", data[d]);
        if(d > 0 && data[d] == data[d-1])
            errors++;
    }
    printf("\n");
    printf("errors: %ld\n", errors);
    fprintf(foutDataWords, "\n");
	fprintf(foutDataWords, "errors: %ld\n", errors);
	fclose(foutDataWords);
    #ifdef debugLEDs
    if(errors > 0)
        led1 = 1;
    #endif
    #elif defined(saveData)
    printf("\nData received (%d words):\n", dataWordIndex);
    fprintf(foutDataWords, "\nData received (%d words):\n", dataWordIndex);
    long errors = 0;
    long badWords = 0;
    for(int w = 0; w < dataWordIndex; w++)
    {
        errors = 0;
        printf("  ");
        fprintf(foutDataWords, "  ");
        for(int b = 0; b < dataWordLength; b++)
        {
            printf("%d", data[w][b]);
            fprintf(foutDataWords, "%d", data[w][b]);
            if(b > 0 && data[w][b-1] == data[w][b])
                errors++;
        }
        if(errors > 0)
        {
            printf(" X");
            fprintf(foutDataWords, " X");
            badWords++;
        }
        printf("\n");
        fprintf(foutDataWords, "\n");
    }
    printf("\nbad words: %d\n", badWords);
    fprintf(foutDataWords, "\nbad words: %d\n", badWords);
    fclose(foutDataWords);
    #ifdef debugLEDs
    if(badWords > 0)
        led1 = 1;
    #endif
    #endif
    wait(1);
    printf("\nDone!");
    wait(3);
    printf("\n");
}

void lowBatteryCallback()
{
    // Stop the tone detector
    // This will end the main call to start, causing main to terminate
    // Main will then also stop the fish controller
    toneDetector.stop();
    printf("Low battery!\n");
    // Also force the pin low to signal the Pi
    // (should have already been done, but just in case)
    DigitalOut simBatteryLow(lowBatteryVoltagePin);
    simBatteryLow = 0;
}





#endif
